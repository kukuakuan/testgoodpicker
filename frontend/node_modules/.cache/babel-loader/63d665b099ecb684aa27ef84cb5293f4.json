{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport RelativeTimeFormatPolyfill from 'relative-time-format';\nimport Cache from './cache';\nimport chooseLocale from './locale';\nimport getStep from './steps/getStep';\nimport getStepDenominator from './steps/getStepDenominator';\nimport getTimeToNextUpdate from './steps/getTimeToNextUpdate';\nimport { addLocaleData, getLocaleData } from './LocaleDataStore';\nimport defaultStyle from './style/roundMinute';\nimport getStyleByName from './style/getStyleByName';\nimport { getRoundFunction } from './round'; // Valid time units.\n\nvar UNITS = ['now', // The rest are the same as in `Intl.RelativeTimeFormat`.\n'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];\n\nvar TimeAgo = /*#__PURE__*/function () {\n  /**\r\n   * @param {(string|string[])} locales=[] - Preferred locales (or locale).\r\n   * @param {boolean} [polyfill] — Pass `false` to use native `Intl.RelativeTimeFormat` and `Intl.PluralRules` instead of the polyfills.\r\n   */\n  function TimeAgo() {\n    var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        polyfill = _ref.polyfill;\n\n    _classCallCheck(this, TimeAgo); // Convert `locales` to an array.\n\n\n    if (typeof locales === 'string') {\n      locales = [locales];\n    } // Choose the most appropriate locale\n    // from the list of `locales` added by the user.\n    // For example, new TimeAgo(\"en-US\") -> \"en\".\n\n\n    this.locale = chooseLocale(locales.concat(TimeAgo.getDefaultLocale()), getLocaleData);\n\n    if (typeof Intl !== 'undefined') {\n      // Use `Intl.NumberFormat` for formatting numbers (when available).\n      if (Intl.NumberFormat) {\n        this.numberFormat = new Intl.NumberFormat(this.locale);\n      }\n    } // Some people have requested the ability to use native\n    // `Intl.RelativeTimeFormat` and `Intl.PluralRules`\n    // instead of the polyfills.\n    // https://github.com/catamphetamine/javascript-time-ago/issues/21\n\n\n    if (polyfill === false) {\n      this.IntlRelativeTimeFormat = Intl.RelativeTimeFormat;\n      this.IntlPluralRules = Intl.PluralRules;\n    } else {\n      this.IntlRelativeTimeFormat = RelativeTimeFormatPolyfill;\n      this.IntlPluralRules = RelativeTimeFormatPolyfill.PluralRules;\n    } // Cache `Intl.RelativeTimeFormat` instance.\n\n\n    this.relativeTimeFormatCache = new Cache(); // Cache `Intl.PluralRules` instance.\n\n    this.pluralRulesCache = new Cache();\n  }\n  /**\r\n   * Formats relative date/time.\r\n   *\r\n   * @param {number} [options.now] - Sets the current date timestamp.\r\n   *\r\n   * @param  {boolean} [options.future] — Tells how to format value `0`:\r\n   *         as \"future\" (`true`) or \"past\" (`false`).\r\n   *         Is `false` by default, but should have been `true` actually,\r\n   *         in order to correspond to `Intl.RelativeTimeFormat`\r\n   *         that uses `future` formatting for `0` unless `-0` is passed.\r\n   *\r\n   * @param {string} [options.round] — Rounding method. Overrides the style's one.\r\n   *\r\n   * @param {boolean} [options.getTimeToNextUpdate] — Pass `true` to return `[formattedDate, timeToNextUpdate]` instead of just `formattedDate`.\r\n   *\r\n   * @return {string} The formatted relative date/time. If no eligible `step` is found, then an empty string is returned.\r\n   */\n\n\n  _createClass(TimeAgo, [{\n    key: \"format\",\n    value: function format(input, style, options) {\n      if (!options) {\n        if (style && !isStyle(style)) {\n          options = style;\n          style = undefined;\n        } else {\n          options = {};\n        }\n      }\n\n      if (!style) {\n        style = defaultStyle;\n      }\n\n      if (typeof style === 'string') {\n        style = getStyleByName(style);\n      }\n\n      var timestamp = getTimestamp(input); // Get locale messages for this type of labels.\n      // \"flavour\" is a legacy name for \"labels\".\n\n      var _this$getLabels = this.getLabels(style.flavour || style.labels),\n          labels = _this$getLabels.labels,\n          labelsType = _this$getLabels.labelsType;\n\n      var now; // Can pass a custom `now`, e.g. for testing purposes.\n      //\n      // Legacy way was passing `now` in `style`.\n      // That way is deprecated.\n\n      if (style.now !== undefined) {\n        now = style.now;\n      } // The new way is passing `now` option to `.format()`.\n\n\n      if (now === undefined && options.now !== undefined) {\n        now = options.now;\n      }\n\n      if (now === undefined) {\n        now = Date.now();\n      } // how much time has passed (in seconds)\n\n\n      var secondsPassed = (now - timestamp) / 1000; // in seconds\n\n      var future = options.future || secondsPassed < 0;\n      var nowLabel = getNowLabel(labels, getLocaleData(this.locale).now, getLocaleData(this.locale).long, future); // `custom` – A function of `{ elapsed, time, date, now, locale }`.\n      //\n      // Looks like `custom` function is deprecated and will be removed\n      // in the next major version.\n      //\n      // If this function returns a value, then the `.format()` call will return that value.\n      // Otherwise the relative date/time is formatted as usual.\n      // This feature is currently not used anywhere and is here\n      // just for providing the ultimate customization point\n      // in case anyone would ever need that. Prefer using\n      // `steps[step].format(value, locale)` instead.\n      //\n\n      if (style.custom) {\n        var custom = style.custom({\n          now: now,\n          date: new Date(timestamp),\n          time: timestamp,\n          elapsed: secondsPassed,\n          locale: this.locale\n        });\n\n        if (custom !== undefined) {\n          // Won't return `timeToNextUpdate` here\n          // because `custom()` seems deprecated.\n          return custom;\n        }\n      } // Get the list of available time interval units.\n\n\n      var units = getTimeIntervalMeasurementUnits( // Controlling `style.steps` through `style.units` seems to be deprecated:\n      // create a new custom `style` instead.\n      style.units, labels, nowLabel); // // If no available time unit is suitable, just output an empty string.\n      // if (units.length === 0) {\n      // \tconsole.error(`None of the \"${units.join(', ')}\" time units have been found in \"${labelsType}\" labels for \"${this.locale}\" locale.`)\n      // \treturn ''\n      // }\n\n      var round = options.round || style.round; // Choose the appropriate time measurement unit\n      // and get the corresponding rounded time amount.\n\n      var _getStep = getStep( // \"gradation\" is a legacy name for \"steps\".\n      // For historical reasons, \"approximate\" steps are used by default.\n      // In the next major version, there'll be no default for `steps`.\n      style.gradation || style.steps || defaultStyle.steps, secondsPassed, {\n        now: now,\n        units: units,\n        round: round,\n        future: future,\n        getNextStep: true\n      }),\n          _getStep2 = _slicedToArray(_getStep, 3),\n          prevStep = _getStep2[0],\n          step = _getStep2[1],\n          nextStep = _getStep2[2];\n\n      var formattedDate = this.formatDateForStep(timestamp, step, secondsPassed, {\n        labels: labels,\n        labelsType: labelsType,\n        nowLabel: nowLabel,\n        now: now,\n        future: future,\n        round: round\n      }) || '';\n\n      if (options.getTimeToNextUpdate) {\n        var timeToNextUpdate = getTimeToNextUpdate(timestamp, step, {\n          nextStep: nextStep,\n          prevStep: prevStep,\n          now: now,\n          future: future,\n          round: round\n        });\n        return [formattedDate, timeToNextUpdate];\n      }\n\n      return formattedDate;\n    }\n  }, {\n    key: \"formatDateForStep\",\n    value: function formatDateForStep(timestamp, step, secondsPassed, _ref2) {\n      var _this = this;\n\n      var labels = _ref2.labels,\n          labelsType = _ref2.labelsType,\n          nowLabel = _ref2.nowLabel,\n          now = _ref2.now,\n          future = _ref2.future,\n          round = _ref2.round; // If no step matches, then output an empty string.\n\n      if (!step) {\n        return;\n      }\n\n      if (step.format) {\n        return step.format(timestamp, this.locale, {\n          formatAs: function formatAs(unit, value) {\n            // Mimicks `Intl.RelativeTimeFormat.format()`.\n            return _this.formatValue(value, unit, {\n              labels: labels,\n              future: future\n            });\n          },\n          now: now,\n          future: future\n        });\n      } // \"unit\" is now called \"formatAs\".\n\n\n      var unit = step.unit || step.formatAs;\n\n      if (!unit) {\n        throw new Error(\"[javascript-time-ago] Each step must define either `formatAs` or `format()`. Step: \".concat(JSON.stringify(step)));\n      } // `Intl.RelativeTimeFormat` doesn't operate in \"now\" units.\n      // Therefore, threat \"now\" as a special case.\n\n\n      if (unit === 'now') {\n        return nowLabel;\n      } // Amount in units.\n\n\n      var amount = Math.abs(secondsPassed) / getStepDenominator(step); // Apply granularity to the time amount\n      // (and fallback to the previous step\n      //  if the first level of granularity\n      //  isn't met by this amount)\n      //\n      // `granularity` — (advanced) Time interval value \"granularity\".\n      // For example, it could be set to `5` for minutes to allow only 5-minute increments\n      // when formatting time intervals: `0 minutes`, `5 minutes`, `10 minutes`, etc.\n      // Perhaps this feature will be removed because there seem to be no use cases\n      // of it in the real world.\n      //\n\n      if (step.granularity) {\n        // Recalculate the amount of seconds passed based on granularity\n        amount = getRoundFunction(round)(amount / step.granularity) * step.granularity;\n      }\n\n      var valueForFormatting = -1 * Math.sign(secondsPassed) * getRoundFunction(round)(amount); // By default, this library formats a `0` in \"past\" mode,\n      // unless `future: true` option is passed.\n      // This is different to `relative-time-format`'s behavior\n      // which formats a `0` in \"future\" mode by default, unless it's a `-0`.\n      // So, convert `0` to `-0` if `future: true` option wasn't passed.\n      // `=== 0` matches both `0` and `-0`.\n\n      if (valueForFormatting === 0) {\n        if (future) {\n          valueForFormatting = 0;\n        } else {\n          valueForFormatting = -0;\n        }\n      }\n\n      switch (labelsType) {\n        case 'long':\n        case 'short':\n        case 'narrow':\n          // Format the amount using `Intl.RelativeTimeFormat`.\n          return this.getFormatter(labelsType).format(valueForFormatting, unit);\n\n        default:\n          // Format the amount.\n          // (mimicks `Intl.RelativeTimeFormat` behavior for other time label styles)\n          return this.formatValue(valueForFormatting, unit, {\n            labels: labels,\n            future: future\n          });\n      }\n    }\n    /**\r\n     * Mimicks what `Intl.RelativeTimeFormat` does for additional locale styles.\r\n     * @param  {number} value\r\n     * @param  {string} unit\r\n     * @param  {object} options.labels — Relative time labels.\r\n     * @param  {boolean} [options.future] — Tells how to format value `0`: as \"future\" (`true`) or \"past\" (`false`). Is `false` by default, but should have been `true` actually.\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"formatValue\",\n    value: function formatValue(value, unit, _ref3) {\n      var labels = _ref3.labels,\n          future = _ref3.future;\n      return this.getFormattingRule(labels, unit, value, {\n        future: future\n      }).replace('{0}', this.formatNumber(Math.abs(value)));\n    }\n    /**\r\n     * Returns formatting rule for `value` in `units` (either in past or in future).\r\n     * @param {object} formattingRules — Relative time labels for different units.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @param {number} value - Time interval value.\r\n     * @param  {boolean} [options.future] — Tells how to format value `0`: as \"future\" (`true`) or \"past\" (`false`). Is `false` by default.\r\n     * @return {string}\r\n     * @example\r\n     * // Returns \"{0} days ago\"\r\n     * getFormattingRule(en.long, \"day\", -2, 'en')\r\n     */\n\n  }, {\n    key: \"getFormattingRule\",\n    value: function getFormattingRule(formattingRules, unit, value, _ref4) {\n      var future = _ref4.future; // Passing the language is required in order to\n      // be able to correctly classify the `value` as a number.\n\n      var locale = this.locale;\n      formattingRules = formattingRules[unit]; // Check for a special \"compacted\" rules case:\n      // if formatting rules are the same for \"past\" and \"future\",\n      // and also for all possible `value`s, then those rules are\n      // stored as a single string.\n\n      if (typeof formattingRules === 'string') {\n        return formattingRules;\n      } // Choose either \"past\" or \"future\" based on time `value` sign.\n      // If \"past\" is same as \"future\" then they're stored as \"other\".\n      // If there's only \"other\" then it's being collapsed.\n\n\n      var pastOrFuture = value === 0 ? future ? 'future' : 'past' : value < 0 ? 'past' : 'future';\n      var quantifierRules = formattingRules[pastOrFuture] || formattingRules; // Bundle size optimization technique.\n\n      if (typeof quantifierRules === 'string') {\n        return quantifierRules;\n      } // Quantify `value`.\n\n\n      var quantifier = this.getPluralRules().select(Math.abs(value)); // \"other\" rule is supposed to always be present.\n      // If only \"other\" rule is present then \"rules\" is not an object and is a string.\n\n      return quantifierRules[quantifier] || quantifierRules.other;\n    }\n    /**\r\n     * Formats a number into a string.\r\n     * Uses `Intl.NumberFormat` when available.\r\n     * @param  {number} number\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"formatNumber\",\n    value: function formatNumber(number) {\n      return this.numberFormat ? this.numberFormat.format(number) : String(number);\n    }\n    /**\r\n     * Returns an `Intl.RelativeTimeFormat` for a given `labelsType`.\r\n     * @param {string} labelsType\r\n     * @return {object} `Intl.RelativeTimeFormat` instance\r\n     */\n\n  }, {\n    key: \"getFormatter\",\n    value: function getFormatter(labelsType) {\n      // `Intl.RelativeTimeFormat` instance creation is (hypothetically) assumed\n      // a lengthy operation so the instances are cached and reused.\n      return this.relativeTimeFormatCache.get(this.locale, labelsType) || this.relativeTimeFormatCache.put(this.locale, labelsType, new this.IntlRelativeTimeFormat(this.locale, {\n        style: labelsType\n      }));\n    }\n    /**\r\n     * Returns an `Intl.PluralRules` instance.\r\n     * @return {object} `Intl.PluralRules` instance\r\n     */\n\n  }, {\n    key: \"getPluralRules\",\n    value: function getPluralRules() {\n      // `Intl.PluralRules` instance creation is (hypothetically) assumed\n      // a lengthy operation so the instances are cached and reused.\n      return this.pluralRulesCache.get(this.locale) || this.pluralRulesCache.put(this.locale, new this.IntlPluralRules(this.locale));\n    }\n    /**\r\n     * Gets localized labels for this type of labels.\r\n     *\r\n     * @param {(string|string[])} labelsType - Relative date/time labels type.\r\n     *                                     If it's an array then all label types are tried\r\n     *                                     until a suitable one is found.\r\n     *\r\n     * @returns {Object} Returns an object of shape { labelsType, labels }\r\n     */\n\n  }, {\n    key: \"getLabels\",\n    value: function getLabels() {\n      var labelsType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Convert `labels` to an array.\n\n      if (typeof labelsType === 'string') {\n        labelsType = [labelsType];\n      } // Supports legacy \"tiny\" and \"mini-time\" label styles.\n\n\n      labelsType = labelsType.map(function (labelsType) {\n        switch (labelsType) {\n          case 'tiny':\n          case 'mini-time':\n            return 'mini';\n\n          default:\n            return labelsType;\n        }\n      }); // \"long\" labels type is the default one.\n      // (it's always present for all languages)\n\n      labelsType = labelsType.concat('long'); // Find a suitable labels type.\n\n      var localeData = getLocaleData(this.locale);\n\n      for (var _iterator = labelsType, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref5;\n\n        if (_isArray) {\n          if (_i2 >= _iterator.length) break;\n          _ref5 = _iterator[_i2++];\n        } else {\n          _i2 = _iterator.next();\n          if (_i2.done) break;\n          _ref5 = _i2.value;\n        }\n\n        var _labelsType = _ref5;\n\n        if (localeData[_labelsType]) {\n          return {\n            labelsType: _labelsType,\n            labels: localeData[_labelsType]\n          };\n        }\n      }\n    }\n  }]);\n\n  return TimeAgo;\n}();\n/**\r\n * Default locale global variable.\r\n */\n\n\nexport { TimeAgo as default };\nvar defaultLocale = 'en';\n/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */\n\nTimeAgo.getDefaultLocale = function () {\n  return defaultLocale;\n};\n/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */\n\n\nTimeAgo.setDefaultLocale = function (locale) {\n  return defaultLocale = locale;\n};\n/**\r\n * Adds locale data for a specific locale and marks the locale as default.\r\n * @param {Object} localeData\r\n */\n\n\nTimeAgo.addDefaultLocale = function (localeData) {\n  if (defaultLocaleHasBeenSpecified) {\n    return console.error('[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`.');\n  }\n\n  defaultLocaleHasBeenSpecified = true;\n  TimeAgo.setDefaultLocale(localeData.locale);\n  TimeAgo.addLocale(localeData);\n};\n\nvar defaultLocaleHasBeenSpecified;\n/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */\n\nTimeAgo.addLocale = function (localeData) {\n  addLocaleData(localeData);\n  RelativeTimeFormatPolyfill.addLocale(localeData);\n};\n/**\r\n * (legacy alias)\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n * @deprecated\r\n */\n\n\nTimeAgo.locale = TimeAgo.addLocale;\n/**\r\n * Adds custom labels to locale data.\r\n * @param {string} locale\r\n * @param {string} name\r\n * @param {object} labels\r\n */\n\nTimeAgo.addLabels = function (locale, name, labels) {\n  var localeData = getLocaleData(locale);\n\n  if (!localeData) {\n    addLocaleData({\n      locale: locale\n    });\n    localeData = getLocaleData(locale); // throw new Error(`[javascript-time-ago] No data for locale \"${locale}\"`)\n  }\n\n  localeData[name] = labels;\n}; // Normalizes `.format()` `time` argument.\n\n\nfunction getTimestamp(input) {\n  if (input.constructor === Date || isMockedDate(input)) {\n    return input.getTime();\n  }\n\n  if (typeof input === 'number') {\n    return input;\n  } // For some weird reason istanbul doesn't see this `throw` covered.\n\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unsupported relative time formatter input: \".concat(_typeof(input), \", \").concat(input));\n} // During testing via some testing libraries `Date`s aren't actually `Date`s.\n// https://github.com/catamphetamine/javascript-time-ago/issues/22\n\n\nfunction isMockedDate(object) {\n  return _typeof(object) === 'object' && typeof object.getTime === 'function';\n} // Get available time interval measurement units.\n\n\nfunction getTimeIntervalMeasurementUnits(allowedUnits, labels, nowLabel) {\n  // Get all time interval measurement units that're available\n  // in locale data for a given time labels style.\n  var units = Object.keys(labels); // `now` unit is handled separately and is shipped in its own `now.json` file.\n  // `now.json` isn't present for all locales, so it could be substituted with\n  // \".second.current\".\n  // Add `now` unit if it's available in locale data.\n\n  if (nowLabel) {\n    units.push('now');\n  } // If only a specific set of available time measurement units can be used\n  // then only those units are allowed (if they're present in locale data).\n\n\n  if (allowedUnits) {\n    units = allowedUnits.filter(function (unit) {\n      return unit === 'now' || units.indexOf(unit) >= 0;\n    });\n  }\n\n  return units;\n}\n\nfunction getNowLabel(labels, nowLabels, longLabels, future) {\n  var nowLabel = labels.now || nowLabels && nowLabels.now; // Specific \"now\" message form extended locale data (if present).\n\n  if (nowLabel) {\n    // Bundle size optimization technique.\n    if (typeof nowLabel === 'string') {\n      return nowLabel;\n    } // Not handling `value === 0` as `localeData.now.current` here\n    // because it wouldn't make sense: \"now\" is a moment,\n    // so one can't possibly differentiate between a\n    // \"previous\" moment, a \"current\" moment and a \"next moment\".\n    // It can only be differentiated between \"past\" and \"future\".\n\n\n    if (future) {\n      return nowLabel.future;\n    } else {\n      return nowLabel.past;\n    }\n  } // Use \".second.current\" as \"now\" message.\n\n\n  if (longLabels && longLabels.second && longLabels.second.current) {\n    return longLabels.second.current;\n  }\n}\n\nvar OBJECT_CONSTRUCTOR = {}.constructor;\n\nfunction isObject(object) {\n  return _typeof(object) !== undefined && object !== null && object.constructor === OBJECT_CONSTRUCTOR;\n}\n\nfunction isStyle(variable) {\n  return typeof variable === 'string' || isStyleObject(variable);\n}\n\nexport function isStyleObject(object) {\n  return isObject(object) && (Array.isArray(object.steps) || // `gradation` property is deprecated: it has been renamed to `steps`.\n  Array.isArray(object.gradation) || // `flavour` property is deprecated: it has been renamed to `labels`.\n  Array.isArray(object.flavour) || typeof object.flavour === 'string' || Array.isArray(object.labels) || typeof object.labels === 'string' || // `units` property is deprecated.\n  Array.isArray(object.units) || // `custom` property is deprecated.\n  typeof object.custom === 'function');\n}","map":{"version":3,"sources":["../source/TimeAgo.js"],"names":["UNITS","TimeAgo","locales","polyfill","chooseLocale","Intl","RelativeTimeFormatPolyfill","input","style","options","isStyle","getStyleByName","timestamp","getTimestamp","labels","labelsType","now","Date","secondsPassed","future","nowLabel","getNowLabel","getLocaleData","custom","date","time","elapsed","locale","units","getTimeIntervalMeasurementUnits","round","prevStep","step","nextStep","getStep","defaultStyle","getNextStep","formattedDate","timeToNextUpdate","getTimeToNextUpdate","formatAs","unit","JSON","amount","Math","getStepDenominator","getRoundFunction","valueForFormatting","value","formattingRules","pastOrFuture","quantifierRules","quantifier","number","String","localeData","_labelsType","defaultLocale","console","defaultLocaleHasBeenSpecified","addLocaleData","isMockedDate","object","Object","nowLabels","longLabels","OBJECT_CONSTRUCTOR","isStyleObject","isObject","Array"],"mappings":"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","sourcesContent":["import RelativeTimeFormatPolyfill from 'relative-time-format'\r\n\r\nimport Cache from './cache'\r\nimport chooseLocale from './locale'\r\nimport getStep from './steps/getStep'\r\nimport getStepDenominator from './steps/getStepDenominator'\r\nimport getTimeToNextUpdate from './steps/getTimeToNextUpdate'\r\n\r\nimport {\r\n\taddLocaleData,\r\n\tgetLocaleData\r\n} from './LocaleDataStore'\r\n\r\nimport defaultStyle from './style/roundMinute'\r\nimport getStyleByName from './style/getStyleByName'\r\n\r\nimport { getRoundFunction } from './round'\r\n\r\n// Valid time units.\r\nconst UNITS = [\r\n\t'now',\r\n\t// The rest are the same as in `Intl.RelativeTimeFormat`.\r\n\t'second',\r\n\t'minute',\r\n\t'hour',\r\n\t'day',\r\n\t'week',\r\n\t'month',\r\n\t'quarter',\r\n\t'year'\r\n]\r\n\r\nexport default class TimeAgo {\r\n\t/**\r\n\t * @param {(string|string[])} locales=[] - Preferred locales (or locale).\r\n\t * @param {boolean} [polyfill] — Pass `false` to use native `Intl.RelativeTimeFormat` and `Intl.PluralRules` instead of the polyfills.\r\n\t */\r\n\tconstructor(locales = [], { polyfill } = {}) {\r\n\t\t// Convert `locales` to an array.\r\n\t\tif (typeof locales === 'string') {\r\n\t\t\tlocales = [locales]\r\n\t\t}\r\n\r\n\t\t// Choose the most appropriate locale\r\n\t\t// from the list of `locales` added by the user.\r\n\t\t// For example, new TimeAgo(\"en-US\") -> \"en\".\r\n\t\tthis.locale = chooseLocale(\r\n\t\t\tlocales.concat(TimeAgo.getDefaultLocale()),\r\n\t\t\tgetLocaleData\r\n\t\t)\r\n\r\n\t\tif (typeof Intl !== 'undefined') {\r\n\t\t\t// Use `Intl.NumberFormat` for formatting numbers (when available).\r\n\t\t\tif (Intl.NumberFormat) {\r\n\t\t\t\tthis.numberFormat = new Intl.NumberFormat(this.locale)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Some people have requested the ability to use native\r\n\t\t// `Intl.RelativeTimeFormat` and `Intl.PluralRules`\r\n\t\t// instead of the polyfills.\r\n\t\t// https://github.com/catamphetamine/javascript-time-ago/issues/21\r\n\t\tif (polyfill === false) {\r\n\t\t\tthis.IntlRelativeTimeFormat = Intl.RelativeTimeFormat\r\n\t\t\tthis.IntlPluralRules = Intl.PluralRules\r\n\t\t} else {\r\n\t\t\tthis.IntlRelativeTimeFormat = RelativeTimeFormatPolyfill\r\n\t\t\tthis.IntlPluralRules = RelativeTimeFormatPolyfill.PluralRules\r\n\t\t}\r\n\r\n\t\t// Cache `Intl.RelativeTimeFormat` instance.\r\n\t\tthis.relativeTimeFormatCache = new Cache()\r\n\r\n\t\t// Cache `Intl.PluralRules` instance.\r\n\t\tthis.pluralRulesCache = new Cache()\r\n\t}\r\n\r\n\t/**\r\n\t * Formats relative date/time.\r\n\t *\r\n\t * @param {number} [options.now] - Sets the current date timestamp.\r\n\t *\r\n\t * @param  {boolean} [options.future] — Tells how to format value `0`:\r\n\t *         as \"future\" (`true`) or \"past\" (`false`).\r\n\t *         Is `false` by default, but should have been `true` actually,\r\n\t *         in order to correspond to `Intl.RelativeTimeFormat`\r\n\t *         that uses `future` formatting for `0` unless `-0` is passed.\r\n\t *\r\n\t * @param {string} [options.round] — Rounding method. Overrides the style's one.\r\n\t *\r\n\t * @param {boolean} [options.getTimeToNextUpdate] — Pass `true` to return `[formattedDate, timeToNextUpdate]` instead of just `formattedDate`.\r\n\t *\r\n\t * @return {string} The formatted relative date/time. If no eligible `step` is found, then an empty string is returned.\r\n\t */\r\n\tformat(input, style, options) {\r\n\t\tif (!options) {\r\n\t\t\tif (style && !isStyle(style)) {\r\n\t\t\t\toptions = style\r\n\t\t\t\tstyle = undefined\r\n\t\t\t} else {\r\n\t\t\t\toptions = {}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!style) {\r\n\t\t\tstyle = defaultStyle\r\n\t\t}\r\n\r\n\t\tif (typeof style === 'string') {\r\n\t\t\tstyle = getStyleByName(style)\r\n\t\t}\r\n\r\n\t\tconst timestamp = getTimestamp(input)\r\n\r\n\t\t// Get locale messages for this type of labels.\r\n\t\t// \"flavour\" is a legacy name for \"labels\".\r\n\t\tconst { labels, labelsType } = this.getLabels(style.flavour || style.labels)\r\n\r\n\t\tlet now\r\n\t\t// Can pass a custom `now`, e.g. for testing purposes.\r\n\t\t//\r\n\t\t// Legacy way was passing `now` in `style`.\r\n\t\t// That way is deprecated.\r\n\t\tif (style.now !== undefined) {\r\n\t\t\tnow = style.now\r\n\t\t}\r\n\t\t// The new way is passing `now` option to `.format()`.\r\n\t\tif (now === undefined && options.now !== undefined) {\r\n\t\t\tnow = options.now\r\n\t\t}\r\n\t\tif (now === undefined) {\r\n\t\t\tnow = Date.now()\r\n\t\t}\r\n\r\n\t\t// how much time has passed (in seconds)\r\n\t\tconst secondsPassed = (now - timestamp) / 1000 // in seconds\r\n\r\n\t\tconst future = options.future || secondsPassed < 0\r\n\r\n\t\tconst nowLabel = getNowLabel(\r\n\t\t\tlabels,\r\n\t\t\tgetLocaleData(this.locale).now,\r\n\t\t\tgetLocaleData(this.locale).long,\r\n\t\t\tfuture\r\n\t\t)\r\n\r\n\t\t// `custom` – A function of `{ elapsed, time, date, now, locale }`.\r\n\t\t//\r\n\t\t// Looks like `custom` function is deprecated and will be removed\r\n\t\t// in the next major version.\r\n\t\t//\r\n\t\t// If this function returns a value, then the `.format()` call will return that value.\r\n\t\t// Otherwise the relative date/time is formatted as usual.\r\n\t\t// This feature is currently not used anywhere and is here\r\n\t\t// just for providing the ultimate customization point\r\n\t\t// in case anyone would ever need that. Prefer using\r\n\t\t// `steps[step].format(value, locale)` instead.\r\n\t\t//\r\n\t\tif (style.custom) {\r\n\t\t\tconst custom = style.custom({\r\n\t\t\t\tnow,\r\n\t\t\t\tdate: new Date(timestamp),\r\n\t\t\t\ttime: timestamp,\r\n\t\t\t\telapsed: secondsPassed,\r\n\t\t\t\tlocale: this.locale\r\n\t\t\t})\r\n\t\t\tif (custom !== undefined) {\r\n\t\t\t\t// Won't return `timeToNextUpdate` here\r\n\t\t\t\t// because `custom()` seems deprecated.\r\n\t\t\t\treturn custom\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Get the list of available time interval units.\r\n\t\tconst units = getTimeIntervalMeasurementUnits(\r\n\t\t\t// Controlling `style.steps` through `style.units` seems to be deprecated:\r\n\t\t\t// create a new custom `style` instead.\r\n\t\t\tstyle.units,\r\n\t\t\tlabels,\r\n\t\t\tnowLabel\r\n\t\t)\r\n\r\n\t\t// // If no available time unit is suitable, just output an empty string.\r\n\t\t// if (units.length === 0) {\r\n\t\t// \tconsole.error(`None of the \"${units.join(', ')}\" time units have been found in \"${labelsType}\" labels for \"${this.locale}\" locale.`)\r\n\t\t// \treturn ''\r\n\t\t// }\r\n\r\n\t\tconst round = options.round || style.round\r\n\r\n\t\t// Choose the appropriate time measurement unit\r\n\t\t// and get the corresponding rounded time amount.\r\n\t\tconst [prevStep, step, nextStep] = getStep(\r\n\t\t\t// \"gradation\" is a legacy name for \"steps\".\r\n\t\t\t// For historical reasons, \"approximate\" steps are used by default.\r\n\t\t\t// In the next major version, there'll be no default for `steps`.\r\n\t\t\tstyle.gradation || style.steps || defaultStyle.steps,\r\n\t\t\tsecondsPassed,\r\n\t\t\t{ now, units, round, future, getNextStep: true }\r\n\t\t)\r\n\r\n\t\tconst formattedDate = this.formatDateForStep(timestamp, step, secondsPassed, {\r\n\t\t\tlabels,\r\n\t\t\tlabelsType,\r\n\t\t\tnowLabel,\r\n\t\t\tnow,\r\n\t\t\tfuture,\r\n\t\t\tround\r\n\t\t}) || ''\r\n\r\n\t\tif (options.getTimeToNextUpdate) {\r\n\t\t\tconst timeToNextUpdate = getTimeToNextUpdate(timestamp, step, {\r\n\t\t\t\tnextStep,\r\n\t\t\t\tprevStep,\r\n\t\t\t\tnow,\r\n\t\t\t\tfuture,\r\n\t\t\t\tround\r\n\t\t\t})\r\n\t\t\treturn [formattedDate, timeToNextUpdate]\r\n\t\t}\r\n\r\n\t\treturn formattedDate\r\n\t}\r\n\r\n\tformatDateForStep(timestamp, step, secondsPassed, {\r\n\t\tlabels,\r\n\t\tlabelsType,\r\n\t\tnowLabel,\r\n\t\tnow,\r\n\t\tfuture,\r\n\t\tround\r\n\t}) {\r\n\t\t// If no step matches, then output an empty string.\r\n\t\tif (!step) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (step.format) {\r\n\t\t\treturn step.format(timestamp, this.locale, {\r\n\t\t\t\tformatAs: (unit, value) => {\r\n\t\t\t\t\t// Mimicks `Intl.RelativeTimeFormat.format()`.\r\n\t\t\t\t\treturn this.formatValue(value, unit, {\r\n\t\t\t\t\t\tlabels,\r\n\t\t\t\t\t\tfuture\r\n\t\t\t\t\t})\r\n\t\t\t\t},\r\n\t\t\t\tnow,\r\n\t\t\t\tfuture\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t// \"unit\" is now called \"formatAs\".\r\n\t\tconst unit = step.unit || step.formatAs\r\n\r\n\t\tif (!unit) {\r\n\t\t\tthrow new Error(`[javascript-time-ago] Each step must define either \\`formatAs\\` or \\`format()\\`. Step: ${JSON.stringify(step)}`)\r\n\t\t}\r\n\r\n\t\t// `Intl.RelativeTimeFormat` doesn't operate in \"now\" units.\r\n\t\t// Therefore, threat \"now\" as a special case.\r\n\t\tif (unit === 'now') {\r\n\t\t\treturn nowLabel\r\n\t\t}\r\n\r\n\t\t// Amount in units.\r\n\t\tlet amount = Math.abs(secondsPassed) / getStepDenominator(step)\r\n\r\n\t\t// Apply granularity to the time amount\r\n\t\t// (and fallback to the previous step\r\n\t\t//  if the first level of granularity\r\n\t\t//  isn't met by this amount)\r\n\t\t//\r\n\t\t// `granularity` — (advanced) Time interval value \"granularity\".\r\n\t\t// For example, it could be set to `5` for minutes to allow only 5-minute increments\r\n\t\t// when formatting time intervals: `0 minutes`, `5 minutes`, `10 minutes`, etc.\r\n\t\t// Perhaps this feature will be removed because there seem to be no use cases\r\n\t\t// of it in the real world.\r\n\t\t//\r\n\t\tif (step.granularity) {\r\n\t\t\t// Recalculate the amount of seconds passed based on granularity\r\n\t\t\tamount = getRoundFunction(round)(amount / step.granularity) * step.granularity\r\n\t\t}\r\n\r\n\t\tlet valueForFormatting = -1 * Math.sign(secondsPassed) * getRoundFunction(round)(amount)\r\n\r\n\t\t// By default, this library formats a `0` in \"past\" mode,\r\n\t\t// unless `future: true` option is passed.\r\n\t\t// This is different to `relative-time-format`'s behavior\r\n\t\t// which formats a `0` in \"future\" mode by default, unless it's a `-0`.\r\n\t\t// So, convert `0` to `-0` if `future: true` option wasn't passed.\r\n\t\t// `=== 0` matches both `0` and `-0`.\r\n\t\tif (valueForFormatting === 0) {\r\n\t\t\tif (future) {\r\n\t\t\t\tvalueForFormatting = 0\r\n\t\t\t} else {\r\n\t\t\t\tvalueForFormatting = -0\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch (labelsType) {\r\n\t\t\tcase 'long':\r\n\t\t\tcase 'short':\r\n\t\t\tcase 'narrow':\r\n\t\t\t\t// Format the amount using `Intl.RelativeTimeFormat`.\r\n\t\t\t\treturn this.getFormatter(labelsType).format(valueForFormatting, unit)\r\n\t\t\tdefault:\r\n\t\t\t\t// Format the amount.\r\n\t\t\t\t// (mimicks `Intl.RelativeTimeFormat` behavior for other time label styles)\r\n\t\t\t\treturn this.formatValue(valueForFormatting, unit, {\r\n\t\t\t\t\tlabels,\r\n\t\t\t\t\tfuture\r\n\t\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Mimicks what `Intl.RelativeTimeFormat` does for additional locale styles.\r\n\t * @param  {number} value\r\n\t * @param  {string} unit\r\n\t * @param  {object} options.labels — Relative time labels.\r\n\t * @param  {boolean} [options.future] — Tells how to format value `0`: as \"future\" (`true`) or \"past\" (`false`). Is `false` by default, but should have been `true` actually.\r\n\t * @return {string}\r\n\t */\r\n\tformatValue(value, unit, { labels, future }) {\r\n\t\treturn this.getFormattingRule(labels, unit, value, { future })\r\n\t\t\t.replace('{0}', this.formatNumber(Math.abs(value)))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns formatting rule for `value` in `units` (either in past or in future).\r\n\t * @param {object} formattingRules — Relative time labels for different units.\r\n\t * @param {string} unit - Time interval measurement unit.\r\n\t * @param {number} value - Time interval value.\r\n\t * @param  {boolean} [options.future] — Tells how to format value `0`: as \"future\" (`true`) or \"past\" (`false`). Is `false` by default.\r\n\t * @return {string}\r\n\t * @example\r\n\t * // Returns \"{0} days ago\"\r\n\t * getFormattingRule(en.long, \"day\", -2, 'en')\r\n\t */\r\n\tgetFormattingRule(formattingRules, unit, value, { future }) {\r\n\t\t// Passing the language is required in order to\r\n\t\t// be able to correctly classify the `value` as a number.\r\n\t\tconst locale = this.locale\r\n\t\tformattingRules = formattingRules[unit]\r\n\t\t// Check for a special \"compacted\" rules case:\r\n\t\t// if formatting rules are the same for \"past\" and \"future\",\r\n\t\t// and also for all possible `value`s, then those rules are\r\n\t\t// stored as a single string.\r\n\t\tif (typeof formattingRules === 'string') {\r\n\t\t\treturn formattingRules\r\n\t\t}\r\n\t\t// Choose either \"past\" or \"future\" based on time `value` sign.\r\n\t\t// If \"past\" is same as \"future\" then they're stored as \"other\".\r\n\t\t// If there's only \"other\" then it's being collapsed.\r\n\t\tconst pastOrFuture = value === 0 ? (future ? 'future' : 'past') : (value < 0 ? 'past' : 'future')\r\n\t\tconst quantifierRules = formattingRules[pastOrFuture] || formattingRules\r\n\t\t// Bundle size optimization technique.\r\n\t\tif (typeof quantifierRules === 'string') {\r\n\t\t\treturn quantifierRules\r\n\t\t}\r\n\t\t// Quantify `value`.\r\n\t\tconst quantifier = this.getPluralRules().select(Math.abs(value))\r\n\t\t// \"other\" rule is supposed to always be present.\r\n\t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\treturn quantifierRules[quantifier] || quantifierRules.other\r\n\t}\r\n\r\n\t/**\r\n\t * Formats a number into a string.\r\n\t * Uses `Intl.NumberFormat` when available.\r\n\t * @param  {number} number\r\n\t * @return {string}\r\n\t */\r\n\tformatNumber(number) {\r\n\t\treturn this.numberFormat ? this.numberFormat.format(number) : String(number)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an `Intl.RelativeTimeFormat` for a given `labelsType`.\r\n\t * @param {string} labelsType\r\n\t * @return {object} `Intl.RelativeTimeFormat` instance\r\n\t */\r\n\tgetFormatter(labelsType) {\r\n\t\t// `Intl.RelativeTimeFormat` instance creation is (hypothetically) assumed\r\n\t\t// a lengthy operation so the instances are cached and reused.\r\n\t\treturn this.relativeTimeFormatCache.get(this.locale, labelsType) ||\r\n\t\t\tthis.relativeTimeFormatCache.put(this.locale, labelsType, new this.IntlRelativeTimeFormat(this.locale, { style: labelsType }))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an `Intl.PluralRules` instance.\r\n\t * @return {object} `Intl.PluralRules` instance\r\n\t */\r\n\tgetPluralRules() {\r\n\t\t// `Intl.PluralRules` instance creation is (hypothetically) assumed\r\n\t\t// a lengthy operation so the instances are cached and reused.\r\n\t\treturn this.pluralRulesCache.get(this.locale) ||\r\n\t\t\tthis.pluralRulesCache.put(this.locale, new this.IntlPluralRules(this.locale))\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets localized labels for this type of labels.\r\n\t *\r\n\t * @param {(string|string[])} labelsType - Relative date/time labels type.\r\n\t *                                     If it's an array then all label types are tried\r\n\t *                                     until a suitable one is found.\r\n\t *\r\n\t * @returns {Object} Returns an object of shape { labelsType, labels }\r\n\t */\r\n\tgetLabels(labelsType = []) {\r\n\t\t// Convert `labels` to an array.\r\n\t\tif (typeof labelsType === 'string') {\r\n\t\t\tlabelsType = [labelsType]\r\n\t\t}\r\n\r\n\t\t// Supports legacy \"tiny\" and \"mini-time\" label styles.\r\n\t\tlabelsType = labelsType.map((labelsType) => {\r\n\t\t\tswitch (labelsType) {\r\n\t\t\t\tcase 'tiny':\r\n\t\t\t\tcase 'mini-time':\r\n\t\t\t\t\treturn 'mini'\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn labelsType\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\t// \"long\" labels type is the default one.\r\n\t\t// (it's always present for all languages)\r\n\t\tlabelsType = labelsType.concat('long')\r\n\r\n\t\t// Find a suitable labels type.\r\n\t\tconst localeData = getLocaleData(this.locale)\r\n\t\tfor (const _labelsType of labelsType) {\r\n\t\t\tif (localeData[_labelsType]) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tlabelsType: _labelsType,\r\n\t\t\t\t\tlabels: localeData[_labelsType]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Default locale global variable.\r\n */\r\nlet defaultLocale = 'en'\r\n\r\n/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */\r\nTimeAgo.getDefaultLocale = () => defaultLocale\r\n\r\n/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */\r\nTimeAgo.setDefaultLocale = (locale) => defaultLocale = locale\r\n\r\n/**\r\n * Adds locale data for a specific locale and marks the locale as default.\r\n * @param {Object} localeData\r\n */\r\nTimeAgo.addDefaultLocale = function(localeData) {\r\n\tif (defaultLocaleHasBeenSpecified) {\r\n\t\treturn console.error('[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`.')\r\n\t}\r\n\tdefaultLocaleHasBeenSpecified = true\r\n\tTimeAgo.setDefaultLocale(localeData.locale)\r\n\tTimeAgo.addLocale(localeData)\r\n}\r\n\r\nlet defaultLocaleHasBeenSpecified\r\n\r\n/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */\r\nTimeAgo.addLocale = function(localeData) {\r\n\taddLocaleData(localeData)\r\n\tRelativeTimeFormatPolyfill.addLocale(localeData)\r\n}\r\n\r\n/**\r\n * (legacy alias)\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n * @deprecated\r\n */\r\nTimeAgo.locale = TimeAgo.addLocale\r\n\r\n/**\r\n * Adds custom labels to locale data.\r\n * @param {string} locale\r\n * @param {string} name\r\n * @param {object} labels\r\n */\r\nTimeAgo.addLabels = (locale, name, labels) => {\r\n\tlet localeData = getLocaleData(locale)\r\n\tif (!localeData) {\r\n\t\taddLocaleData({\r\n\t\t\tlocale\r\n\t\t})\r\n\t\tlocaleData = getLocaleData(locale)\r\n\t\t// throw new Error(`[javascript-time-ago] No data for locale \"${locale}\"`)\r\n\t}\r\n\tlocaleData[name] = labels\r\n}\r\n\r\n// Normalizes `.format()` `time` argument.\r\nfunction getTimestamp(input) {\r\n\tif (input.constructor === Date || isMockedDate(input)) {\r\n\t\treturn input.getTime()\r\n\t}\r\n\r\n\tif (typeof input === 'number') {\r\n\t\treturn input\r\n\t}\r\n\r\n\t// For some weird reason istanbul doesn't see this `throw` covered.\r\n\t/* istanbul ignore next */\r\n\tthrow new Error(`Unsupported relative time formatter input: ${typeof input}, ${input}`)\r\n}\r\n\r\n// During testing via some testing libraries `Date`s aren't actually `Date`s.\r\n// https://github.com/catamphetamine/javascript-time-ago/issues/22\r\nfunction isMockedDate(object) {\r\n\treturn typeof object === 'object' && typeof object.getTime === 'function'\r\n}\r\n\r\n// Get available time interval measurement units.\r\nfunction getTimeIntervalMeasurementUnits(allowedUnits, labels, nowLabel) {\r\n\t// Get all time interval measurement units that're available\r\n\t// in locale data for a given time labels style.\r\n\tlet units = Object.keys(labels)\r\n\r\n\t// `now` unit is handled separately and is shipped in its own `now.json` file.\r\n\t// `now.json` isn't present for all locales, so it could be substituted with\r\n\t// \".second.current\".\r\n\t// Add `now` unit if it's available in locale data.\r\n\tif (nowLabel) {\r\n\t\tunits.push('now')\r\n\t}\r\n\r\n\t// If only a specific set of available time measurement units can be used\r\n\t// then only those units are allowed (if they're present in locale data).\r\n\tif (allowedUnits) {\r\n\t\tunits = allowedUnits.filter(unit => unit === 'now' || units.indexOf(unit) >= 0)\r\n\t}\r\n\r\n\treturn units\r\n}\r\n\r\nfunction getNowLabel(labels, nowLabels, longLabels, future) {\r\n\tconst nowLabel = labels.now || (nowLabels && nowLabels.now)\r\n\t// Specific \"now\" message form extended locale data (if present).\r\n\tif (nowLabel) {\r\n\t\t// Bundle size optimization technique.\r\n\t\tif (typeof nowLabel === 'string') {\r\n\t\t\treturn nowLabel\r\n\t\t}\r\n\t\t// Not handling `value === 0` as `localeData.now.current` here\r\n\t\t// because it wouldn't make sense: \"now\" is a moment,\r\n\t\t// so one can't possibly differentiate between a\r\n\t\t// \"previous\" moment, a \"current\" moment and a \"next moment\".\r\n\t\t// It can only be differentiated between \"past\" and \"future\".\r\n\t\tif (future) {\r\n\t\t\treturn nowLabel.future\r\n\t\t} else {\r\n\t\t\treturn nowLabel.past\r\n\t\t}\r\n\t}\r\n\t// Use \".second.current\" as \"now\" message.\r\n\tif (longLabels && longLabels.second && longLabels.second.current) {\r\n\t\treturn longLabels.second.current\r\n\t}\r\n}\r\n\r\nconst OBJECT_CONSTRUCTOR = {}.constructor\r\nfunction isObject(object) {\r\n\treturn typeof object !== undefined && object !== null && object.constructor === OBJECT_CONSTRUCTOR\r\n}\r\n\r\nfunction isStyle(variable) {\r\n\treturn typeof variable === 'string' || isStyleObject(variable)\r\n}\r\n\r\nexport function isStyleObject(object) {\r\n\treturn isObject(object) && (\r\n\t\tArray.isArray(object.steps) ||\r\n\t\t// `gradation` property is deprecated: it has been renamed to `steps`.\r\n\t\tArray.isArray(object.gradation) ||\r\n\t\t// `flavour` property is deprecated: it has been renamed to `labels`.\r\n\t\tArray.isArray(object.flavour) ||\r\n\t\ttypeof object.flavour === 'string' ||\r\n\t\tArray.isArray(object.labels) ||\r\n\t\ttypeof object.labels === 'string' ||\r\n\t\t// `units` property is deprecated.\r\n\t\tArray.isArray(object.units) ||\r\n\t\t// `custom` property is deprecated.\r\n\t\ttypeof object.custom === 'function'\r\n\t)\r\n}"]},"metadata":{},"sourceType":"module"}