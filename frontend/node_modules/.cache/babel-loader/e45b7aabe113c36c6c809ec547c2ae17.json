{"ast":null,"code":"import { getSecondsInUnit } from './units';\nimport { getRoundFunction, getDiffRatioToNextRoundedNumber } from '../round';\n/**\r\n * Gets the time to next update for a step with a time unit defined.\r\n * @param  {string} unit\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {number} options.now\r\n * @param  {string} [options.round] — (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {\n  var now = _ref.now,\n      round = _ref.round; // For some units, like \"now\", there's no defined amount of seconds in them.\n\n  if (!getSecondsInUnit(unit)) {\n    // If there's no amount of seconds defined for this unit\n    // then the update interval can't be determined reliably.\n    return;\n  }\n\n  var unitDenominator = getSecondsInUnit(unit) * 1000;\n  var future = timestamp > now;\n  var preciseAmount = Math.abs(timestamp - now);\n  var roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator;\n\n  if (future) {\n    if (roundedAmount > 0) {\n      // Amount decreases with time.\n      return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round, unitDenominator);\n    } else {\n      // Refresh right after the zero point,\n      // when \"future\" changes to \"past\".\n      return preciseAmount - roundedAmount + 1;\n    }\n  } // Amount increases with time.\n\n\n  return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator);\n}\n\nfunction getDiffToNextRoundedNumber(round, unitDenominator) {\n  return getDiffRatioToNextRoundedNumber(round) * unitDenominator;\n}\n\nfunction getDiffToPreviousRoundedNumber(round, unitDenominator) {\n  return (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1;\n}","map":{"version":3,"sources":["../../source/steps/getTimeToNextUpdateForUnit.js"],"names":["now","round","getSecondsInUnit","unitDenominator","future","timestamp","preciseAmount","Math","roundedAmount","getRoundFunction","getDiffToPreviousRoundedNumber","getDiffToNextRoundedNumber","getDiffRatioToNextRoundedNumber"],"mappings":"AAAA,SAAA,gBAAA,QAAA,SAAA;AACA,SAAA,gBAAA,EAAA,+BAAA,QAAA,UAAA;AAEA;;;;;;;;;AAQA,eAAe,SAAA,0BAAA,CAAA,IAAA,EAAA,SAAA,EAAA,IAAA,EAAqE;AAAA,MAAdA,GAAc,GAAA,IAAA,CAAdA,GAAc;AAAA,MAATC,KAAS,GAAA,IAAA,CAATA,KAAS,CAAA,CACnF;;AACA,MAAI,CAACC,gBAAgB,CAArB,IAAqB,CAArB,EAA6B;AAC5B;AACA;AACA;AACA;;AACD,MAAMC,eAAe,GAAGD,gBAAgB,CAAhBA,IAAgB,CAAhBA,GAAxB,IAAA;AACA,MAAME,MAAM,GAAGC,SAAS,GAAxB,GAAA;AACA,MAAMC,aAAa,GAAGC,IAAI,CAAJA,GAAAA,CAASF,SAAS,GAAxC,GAAsBE,CAAtB;AACA,MAAMC,aAAa,GAAGC,gBAAgB,CAAhBA,KAAgB,CAAhBA,CAAwBH,aAAa,GAArCG,eAAAA,IAAtB,eAAA;;AACA,MAAA,MAAA,EAAY;AACX,QAAID,aAAa,GAAjB,CAAA,EAAuB;AACtB;AACA,aAAQF,aAAa,GAAd,aAACA,GACPI,8BAA8B,CAAA,KAAA,EAD/B,eAC+B,CAD/B;AAFD,KAAA,MAIO;AACN;AACA;AACA,aAAQJ,aAAa,GAAd,aAACA,GAAR,CAAA;AACA;AApBiF,GAAA,CAsBlF;;;AACD,SAAO,EAAEA,aAAa,GAAf,aAAA,IAAmCK,0BAA0B,CAAA,KAAA,EAApE,eAAoE,CAApE;AACA;;AAED,SAAA,0BAAA,CAAA,KAAA,EAAA,eAAA,EAA4D;AAC3D,SAAOC,+BAA+B,CAA/BA,KAA+B,CAA/BA,GAAP,eAAA;AACA;;AAED,SAAA,8BAAA,CAAA,KAAA,EAAA,eAAA,EAAgE;AAC/D,SAAO,CAAC,IAAIA,+BAA+B,CAApC,KAAoC,CAApC,IAAA,eAAA,GAAP,CAAA;AACA","sourcesContent":["import { getSecondsInUnit } from './units'\r\nimport { getRoundFunction, getDiffRatioToNextRoundedNumber } from '../round'\r\n\r\n/**\r\n * Gets the time to next update for a step with a time unit defined.\r\n * @param  {string} unit\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {number} options.now\r\n * @param  {string} [options.round] — (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\r\nexport default function getTimeToNextUpdateForUnit(unit, timestamp, { now, round }) {\r\n\t// For some units, like \"now\", there's no defined amount of seconds in them.\r\n\tif (!getSecondsInUnit(unit)) {\r\n\t\t// If there's no amount of seconds defined for this unit\r\n\t\t// then the update interval can't be determined reliably.\r\n\t\treturn\r\n\t}\r\n\tconst unitDenominator = getSecondsInUnit(unit) * 1000\r\n\tconst future = timestamp > now\r\n\tconst preciseAmount = Math.abs(timestamp - now)\r\n\tconst roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator\r\n\tif (future) {\r\n\t\tif (roundedAmount > 0) {\r\n\t\t\t// Amount decreases with time.\r\n\t\t\treturn (preciseAmount - roundedAmount) +\r\n\t\t\t\tgetDiffToPreviousRoundedNumber(round, unitDenominator)\r\n\t\t} else {\r\n\t\t\t// Refresh right after the zero point,\r\n\t\t\t// when \"future\" changes to \"past\".\r\n\t\t\treturn (preciseAmount - roundedAmount) + 1\r\n\t\t}\r\n\t}\r\n \t// Amount increases with time.\r\n\treturn -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator)\r\n}\r\n\r\nfunction getDiffToNextRoundedNumber(round, unitDenominator) {\r\n\treturn getDiffRatioToNextRoundedNumber(round) * unitDenominator\r\n}\r\n\r\nfunction getDiffToPreviousRoundedNumber(round, unitDenominator) {\r\n\treturn (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1\r\n}"]},"metadata":{},"sourceType":"module"}