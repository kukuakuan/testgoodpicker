{"ast":null,"code":"import _getTimeToNextUpdateForUnit from './getTimeToNextUpdateForUnit';\nimport getStepMinTime from './getStepMinTime';\nimport { getRoundFunction } from '../round'; // A thousand years is practically a metaphor for \"infinity\".\n\nvar YEAR = 365 * 24 * 60 * 60 * 1000;\nexport var INFINITY = 1000 * YEAR;\n/**\r\n * Gets the time to next update for a date and a step.\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {object} step\r\n * @param  {object} [options.previousStep]\r\n * @param  {object} [options.nextStep]\r\n * @param  {number} options.now\r\n * @param  {boolean} options.future\r\n * @param  {string} [options.round] - (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdate(date, step, _ref) {\n  var prevStep = _ref.prevStep,\n      nextStep = _ref.nextStep,\n      now = _ref.now,\n      future = _ref.future,\n      round = _ref.round;\n  var timestamp = date.getTime ? date.getTime() : date;\n\n  var getTimeToNextUpdateForUnit = function getTimeToNextUpdateForUnit(unit) {\n    return _getTimeToNextUpdateForUnit(unit, timestamp, {\n      now: now,\n      round: round\n    });\n  }; // For future dates, steps move from the last one to the first one,\n  // while for past dates, steps move from the first one to the last one,\n  // due to the fact that time flows in one direction,\n  // and future dates' interval naturally becomes smaller\n  // while past dates' interval naturally grows larger.\n  //\n  // For future dates, it's the transition\n  // from the current step to the previous step,\n  // therefore check the `minTime` of the current step.\n  //\n  // For past dates, it's the transition\n  // from the current step to the next step,\n  // therefore check the `minTime` of the next step.\n  //\n\n\n  var timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {\n    future: future,\n    now: now,\n    round: round,\n    prevStep: future ? prevStep : step // isFirstStep: future && isFirstStep\n\n  });\n\n  if (timeToStepChange === undefined) {\n    // Can't reliably determine \"time to next update\"\n    // if not all of the steps provide `minTime`.\n    return;\n  }\n\n  var timeToNextUpdate;\n\n  if (step) {\n    if (step.getTimeToNextUpdate) {\n      timeToNextUpdate = step.getTimeToNextUpdate(timestamp, {\n        getTimeToNextUpdateForUnit: getTimeToNextUpdateForUnit,\n        getRoundFunction: getRoundFunction,\n        now: now,\n        future: future,\n        round: round\n      });\n    }\n\n    if (timeToNextUpdate === undefined) {\n      // \"unit\" is now called \"formatAs\".\n      var unit = step.unit || step.formatAs;\n\n      if (unit) {\n        // For some units, like \"now\", there's no defined amount of seconds in them.\n        // In such cases, `getTimeToNextUpdateForUnit()` returns `undefined`,\n        // and the next step's `minTime` could be used to calculate the update interval:\n        // it will just assume that the label never changes for this step.\n        timeToNextUpdate = getTimeToNextUpdateForUnit(unit);\n      }\n    }\n  }\n\n  if (timeToNextUpdate === undefined) {\n    return timeToStepChange;\n  }\n\n  return Math.min(timeToNextUpdate, timeToStepChange);\n}\nexport function getStepChangesAt(currentOrNextStep, timestamp, _ref2) {\n  var now = _ref2.now,\n      future = _ref2.future,\n      round = _ref2.round,\n      prevStep = _ref2.prevStep; // The first step's `minTime` is `0` by default.\n  // It doesn't \"change\" steps at zero point\n  // but it does change the wording when switching\n  // from \"future\" to \"past\": \"in ...\" -> \"... ago\".\n  // Therefore, the label should be updated at zero-point too.\n\n  var minTime = getStepMinTime(currentOrNextStep, {\n    timestamp: timestamp,\n    now: now,\n    future: future,\n    round: round,\n    prevStep: prevStep\n  });\n\n  if (minTime === undefined) {\n    return;\n  }\n\n  if (future) {\n    // The step changes to the previous step\n    // as soon as `timestamp - now` becomes\n    // less than the `minTime` of the current step:\n    // `timestamp - now === minTime - 1`\n    // => `now === timestamp - minTime + 1`.\n    return timestamp - minTime * 1000 + 1;\n  } else {\n    // The step changes to the next step\n    // as soon as `now - timestamp` becomes\n    // equal to `minTime` of the next step:\n    // `now - timestamp === minTime`\n    // => `now === timestamp + minTime`.\n    // This is a special case when double-update could be skipped.\n    if (minTime === 0 && timestamp === now) {\n      return INFINITY;\n    }\n\n    return timestamp + minTime * 1000;\n  }\n}\nexport function getTimeToStepChange(step, timestamp, _ref3) {\n  var now = _ref3.now,\n      future = _ref3.future,\n      round = _ref3.round,\n      prevStep = _ref3.prevStep;\n\n  if (step) {\n    var stepChangesAt = getStepChangesAt(step, timestamp, {\n      now: now,\n      future: future,\n      round: round,\n      prevStep: prevStep\n    });\n\n    if (stepChangesAt === undefined) {\n      return;\n    }\n\n    return stepChangesAt - now;\n  } else {\n    if (future) {\n      // No step.\n      // Update right after zero point, when it changes from \"future\" to \"past\".\n      return timestamp - now + 1;\n    } else {\n      // The last step doesn't ever change when `date` is in the past.\n      return INFINITY;\n    }\n  }\n}","map":{"version":3,"sources":["../../source/steps/getTimeToNextUpdate.js"],"names":["YEAR","INFINITY","prevStep","nextStep","now","future","round","timestamp","date","getTimeToNextUpdateForUnit","_getTimeToNextUpdateForUnit","timeToStepChange","getTimeToStepChange","step","timeToNextUpdate","getRoundFunction","unit","Math","minTime","getStepMinTime","stepChangesAt","getStepChangesAt"],"mappings":"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","sourcesContent":["import _getTimeToNextUpdateForUnit from './getTimeToNextUpdateForUnit'\r\nimport getStepMinTime from './getStepMinTime'\r\nimport { getRoundFunction } from '../round'\r\n\r\n// A thousand years is practically a metaphor for \"infinity\".\r\nconst YEAR = 365 * 24 * 60 * 60 * 1000\r\nexport const INFINITY = 1000 * YEAR\r\n\r\n/**\r\n * Gets the time to next update for a date and a step.\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {object} step\r\n * @param  {object} [options.previousStep]\r\n * @param  {object} [options.nextStep]\r\n * @param  {number} options.now\r\n * @param  {boolean} options.future\r\n * @param  {string} [options.round] - (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\r\nexport default function getTimeToNextUpdate(date, step, { prevStep, nextStep, now, future, round }) {\r\n\tconst timestamp = date.getTime ? date.getTime() : date\r\n\r\n\tconst getTimeToNextUpdateForUnit = (unit) => _getTimeToNextUpdateForUnit(unit, timestamp, { now, round })\r\n\r\n\t// For future dates, steps move from the last one to the first one,\r\n\t// while for past dates, steps move from the first one to the last one,\r\n\t// due to the fact that time flows in one direction,\r\n\t// and future dates' interval naturally becomes smaller\r\n\t// while past dates' interval naturally grows larger.\r\n\t//\r\n\t// For future dates, it's the transition\r\n\t// from the current step to the previous step,\r\n\t// therefore check the `minTime` of the current step.\r\n\t//\r\n\t// For past dates, it's the transition\r\n\t// from the current step to the next step,\r\n\t// therefore check the `minTime` of the next step.\r\n\t//\r\n\tconst timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {\r\n\t\tfuture,\r\n\t\tnow,\r\n\t\tround,\r\n\t\tprevStep: future ? prevStep : step,\r\n\t\t// isFirstStep: future && isFirstStep\r\n\t})\r\n\r\n\tif (timeToStepChange === undefined) {\r\n\t\t// Can't reliably determine \"time to next update\"\r\n\t\t// if not all of the steps provide `minTime`.\r\n\t\treturn\r\n\t}\r\n\r\n\tlet timeToNextUpdate\r\n\r\n\tif (step) {\r\n\t\tif (step.getTimeToNextUpdate) {\r\n\t\t\ttimeToNextUpdate = step.getTimeToNextUpdate(timestamp, {\r\n\t\t\t\tgetTimeToNextUpdateForUnit,\r\n\t\t\t\tgetRoundFunction,\r\n\t\t\t\tnow,\r\n\t\t\t\tfuture,\r\n\t\t\t\tround\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tif (timeToNextUpdate === undefined) {\r\n\t\t\t// \"unit\" is now called \"formatAs\".\r\n\t\t\tconst unit = step.unit || step.formatAs\r\n\t\t\tif (unit) {\r\n\t\t\t\t// For some units, like \"now\", there's no defined amount of seconds in them.\r\n\t\t\t\t// In such cases, `getTimeToNextUpdateForUnit()` returns `undefined`,\r\n\t\t\t\t// and the next step's `minTime` could be used to calculate the update interval:\r\n\t\t\t\t// it will just assume that the label never changes for this step.\r\n\t\t\t\ttimeToNextUpdate = getTimeToNextUpdateForUnit(unit)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (timeToNextUpdate === undefined) {\r\n\t\treturn timeToStepChange\r\n\t}\r\n\r\n\treturn Math.min(timeToNextUpdate, timeToStepChange)\r\n}\r\n\r\nexport function getStepChangesAt(currentOrNextStep, timestamp, { now, future, round, prevStep }) {\r\n\t// The first step's `minTime` is `0` by default.\r\n\t// It doesn't \"change\" steps at zero point\r\n\t// but it does change the wording when switching\r\n\t// from \"future\" to \"past\": \"in ...\" -> \"... ago\".\r\n\t// Therefore, the label should be updated at zero-point too.\r\n\tconst minTime = getStepMinTime(currentOrNextStep, { timestamp, now, future, round, prevStep })\r\n\tif (minTime === undefined) {\r\n\t\treturn\r\n\t}\r\n\tif (future) {\r\n\t\t// The step changes to the previous step\r\n\t\t// as soon as `timestamp - now` becomes\r\n\t\t// less than the `minTime` of the current step:\r\n\t\t// `timestamp - now === minTime - 1`\r\n\t\t// => `now === timestamp - minTime + 1`.\r\n\t\treturn timestamp - minTime * 1000 + 1\r\n\t} else {\r\n\t\t// The step changes to the next step\r\n\t\t// as soon as `now - timestamp` becomes\r\n\t\t// equal to `minTime` of the next step:\r\n\t\t// `now - timestamp === minTime`\r\n\t\t// => `now === timestamp + minTime`.\r\n\r\n\t\t// This is a special case when double-update could be skipped.\r\n\t\tif (minTime === 0 && timestamp === now) {\r\n\t\t\treturn INFINITY\r\n\t\t}\r\n\r\n\t\treturn timestamp + minTime * 1000\r\n\t}\r\n}\r\n\r\nexport function getTimeToStepChange(step, timestamp, {\r\n\tnow,\r\n\tfuture,\r\n\tround,\r\n\tprevStep\r\n}) {\r\n\tif (step) {\r\n\t\tconst stepChangesAt = getStepChangesAt(step, timestamp, {\r\n\t\t\tnow,\r\n\t\t\tfuture,\r\n\t\t\tround,\r\n\t\t\tprevStep\r\n\t\t})\r\n\t\tif (stepChangesAt === undefined) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\treturn stepChangesAt - now\r\n\t} else {\r\n\t\tif (future) {\r\n\t\t\t// No step.\r\n\t\t\t// Update right after zero point, when it changes from \"future\" to \"past\".\r\n\t\t\treturn timestamp - now + 1\r\n\t\t} else {\r\n\t\t\t// The last step doesn't ever change when `date` is in the past.\r\n\t\t\treturn INFINITY\r\n\t\t}\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}