{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport getStepDenominator from './getStepDenominator';\nimport getStepMinTime from './getStepMinTime';\nimport { getRoundFunction } from '../round';\n/**\r\n * Finds an appropriate `step` of `steps` for the time interval (in seconds).\r\n *\r\n * @param {Object[]} steps - Time formatting steps.\r\n *\r\n * @param {number} secondsPassed - Time interval (in seconds).\r\n *                                 `< 0` for past dates and `> 0` for future dates.\r\n *\r\n * @param {number} options.now - Current timestamp.\r\n *\r\n * @param {boolean} [options.future] - Whether the date should be formatted as a future one\r\n *                                     instead of a past one.\r\n *\r\n * @param {string} [options.round] - (undocumented) Rounding mechanism.\r\n *\r\n * @param {string[]} [options.units] - A list of allowed time units.\r\n *                                     (Example: ['second', 'minute', 'hour', …])\r\n *\r\n * @param {boolean} [options.getNextStep] - Pass true to return `[step, nextStep]` instead of just `step`.\r\n *\r\n * @return {Object|Object[]} [step] — Either a `step` or `[prevStep, step, nextStep]`.\r\n */\n\nexport default function getStep(steps, secondsPassed, _ref) {\n  var now = _ref.now,\n      future = _ref.future,\n      round = _ref.round,\n      units = _ref.units,\n      getNextStep = _ref.getNextStep; // Ignore steps having not-supported time units in `formatAs`.\n\n  steps = filterStepsByUnits(steps, units);\n\n  var step = _getStep(steps, secondsPassed, {\n    now: now,\n    future: future,\n    round: round\n  });\n\n  if (getNextStep) {\n    if (step) {\n      var prevStep = steps[steps.indexOf(step) - 1];\n      var nextStep = steps[steps.indexOf(step) + 1];\n      return [prevStep, step, nextStep];\n    }\n\n    return [undefined, undefined, steps[0]];\n  }\n\n  return step;\n}\n\nfunction _getStep(steps, secondsPassed, _ref2) {\n  var now = _ref2.now,\n      future = _ref2.future,\n      round = _ref2.round; // If no steps fit the conditions then return nothing.\n\n  if (steps.length === 0) {\n    return;\n  } // Find the most appropriate step.\n\n\n  var i = getStepIndex(steps, secondsPassed, {\n    now: now,\n    future: future || secondsPassed < 0,\n    round: round\n  }); // If no step is applicable the return nothing.\n\n  if (i === -1) {\n    return;\n  }\n\n  var step = steps[i]; // Apply granularity to the time amount\n  // (and fall back to the previous step\n  //  if the first level of granularity\n  //  isn't met by this amount)\n\n  if (step.granularity) {\n    // Recalculate the amount of seconds passed based on `granularity`.\n    var secondsPassedGranular = getRoundFunction(round)(Math.abs(secondsPassed) / getStepDenominator(step) / step.granularity) * step.granularity; // If the granularity for this step is too high,\n    // then fall back to the previous step.\n    // (if there is any previous step)\n\n    if (secondsPassedGranular === 0 && i > 0) {\n      return steps[i - 1];\n    }\n  }\n\n  return step;\n}\n/**\r\n * Iterates through steps until it finds the maximum one satisfying the `minTime` threshold.\r\n * @param  {Object} steps - Steps.\r\n * @param  {number} secondsPassed - How much seconds have passed since the date till `now`.\r\n * @param  {number} options.now - Current timestamp.\r\n * @param  {boolean} options.future - Whether the time interval should be formatted as a future one.\r\n * @param  {number} [i] - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\n\n\nfunction getStepIndex(steps, secondsPassed, options) {\n  var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var minTime = getStepMinTime(steps[i], _objectSpread({\n    prevStep: steps[i - 1],\n    timestamp: options.now - secondsPassed * 1000\n  }, options)); // If `minTime` isn't defined or deduceable for this step, then stop.\n\n  if (minTime === undefined) {\n    return i - 1;\n  } // If the `minTime` threshold for moving from previous step\n  // to this step is too high then return the previous step.\n\n\n  if (Math.abs(secondsPassed) < minTime) {\n    return i - 1;\n  } // If it's the last step then return it.\n\n\n  if (i === steps.length - 1) {\n    return i;\n  } // Move to the next step.\n\n\n  return getStepIndex(steps, secondsPassed, options, i + 1);\n}\n/**\r\n * Leaves only allowed steps.\r\n * @param  {Object[]} steps\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\n\n\nfunction filterStepsByUnits(steps, units) {\n  return steps.filter(function (_ref3) {\n    var unit = _ref3.unit,\n        formatAs = _ref3.formatAs; // \"unit\" is now called \"formatAs\".\n\n    unit = unit || formatAs; // If this step has a `unit` defined\n    // then this `unit` must be in the list of allowed `units`.\n\n    if (unit) {\n      return units.indexOf(unit) >= 0;\n    } // A step is not required to specify a `unit`:\n    // alternatively, it could specify `format()`.\n    // (see \"twitter\" style for an example)\n\n\n    return true;\n  });\n}","map":{"version":3,"sources":["../../source/steps/getStep.js"],"names":["now","future","round","units","getNextStep","steps","filterStepsByUnits","step","_getStep","prevStep","nextStep","i","getStepIndex","secondsPassed","secondsPassedGranular","getRoundFunction","Math","getStepDenominator","minTime","getStepMinTime","timestamp","options","unit","formatAs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,kBAAA,MAAA,sBAAA;AACA,OAAA,cAAA,MAAA,kBAAA;AACA,SAAA,gBAAA,QAAA,UAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAsBA,eAAe,SAAA,OAAA,CAAA,KAAA,EAAA,aAAA,EAAA,IAAA,EAAmF;AAAA,MAA1CA,GAA0C,GAAA,IAAA,CAA1CA,GAA0C;AAAA,MAArCC,MAAqC,GAAA,IAAA,CAArCA,MAAqC;AAAA,MAA7BC,KAA6B,GAAA,IAAA,CAA7BA,KAA6B;AAAA,MAAtBC,KAAsB,GAAA,IAAA,CAAtBA,KAAsB;AAAA,MAAfC,WAAe,GAAA,IAAA,CAAfA,WAAe,CAAA,CACjG;;AACAC,EAAAA,KAAK,GAAGC,kBAAkB,CAAA,KAAA,EAA1BD,KAA0B,CAA1BA;;AACA,MAAME,IAAI,GAAGC,QAAQ,CAAA,KAAA,EAAA,aAAA,EAAuB;AAAER,IAAAA,GAAG,EAAL,GAAA;AAAOC,IAAAA,MAAM,EAAb,MAAA;AAAeC,IAAAA,KAAK,EAALA;AAAf,GAAvB,CAArB;;AACA,MAAA,WAAA,EAAiB;AAChB,QAAA,IAAA,EAAU;AACT,UAAMO,QAAQ,GAAGJ,KAAK,CAACA,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAvB,CAAsB,CAAtB;AACA,UAAMK,QAAQ,GAAGL,KAAK,CAACA,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAvB,CAAsB,CAAtB;AACA,aAAO,CAAA,QAAA,EAAA,IAAA,EAAP,QAAO,CAAP;AACA;;AACD,WAAO,CAAA,SAAA,EAAA,SAAA,EAAuBA,KAAK,CAAnC,CAAmC,CAA5B,CAAP;AACA;;AACD,SAAA,IAAA;AACA;;AAED,SAAA,QAAA,CAAA,KAAA,EAAA,aAAA,EAAA,KAAA,EAAgE;AAAA,MAAtBL,GAAsB,GAAA,KAAA,CAAtBA,GAAsB;AAAA,MAAjBC,MAAiB,GAAA,KAAA,CAAjBA,MAAiB;AAAA,MAATC,KAAS,GAAA,KAAA,CAATA,KAAS,CAAA,CAC/D;;AACA,MAAIG,KAAK,CAALA,MAAAA,KAAJ,CAAA,EAAwB;AACvB;AAH8D,GAAA,CAM/D;;;AACA,MAAMM,CAAC,GAAGC,YAAY,CAAA,KAAA,EAAA,aAAA,EAAuB;AAC5CZ,IAAAA,GAAG,EADyC,GAAA;AAE5CC,IAAAA,MAAM,EAAEA,MAAM,IAAIY,aAAa,GAFa,CAAA;AAG5CX,IAAAA,KAAK,EAALA;AAH4C,GAAvB,CAAtB,CAP+D,CAa/D;;AACA,MAAIS,CAAC,KAAK,CAAV,CAAA,EAAc;AACb;AACA;;AAED,MAAMJ,IAAI,GAAGF,KAAK,CAlB6C,CAkB7C,CAAlB,CAlB+D,CAoB/D;AACA;AACA;AACA;;AACA,MAAIE,IAAI,CAAR,WAAA,EAAsB;AACrB;AACA,QAAMO,qBAAqB,GAAGC,gBAAgB,CAAhBA,KAAgB,CAAhBA,CAAyBC,IAAI,CAAJA,GAAAA,CAAAA,aAAAA,IAA0BC,kBAAkB,CAA7C,IAA6C,CAA5CD,GAAsDT,IAAI,CAAnFQ,WAAAA,IAAmGR,IAAI,CAFhH,WAErB,CAFqB,CAGrB;AACA;AACA;;AACA,QAAIO,qBAAqB,KAArBA,CAAAA,IAA+BH,CAAC,GAApC,CAAA,EAA0C;AACzC,aAAON,KAAK,CAACM,CAAC,GAAd,CAAY,CAAZ;AACA;AACD;;AAED,SAAA,IAAA;AACA;AAED;;;;;;;;;;;AASA,SAAA,YAAA,CAAA,KAAA,EAAA,aAAA,EAAA,OAAA,EAA4D;AAAA,MAAPA,CAAO,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAH,CAAG;AAC3D,MAAMO,OAAO,GAAGC,cAAc,CAACd,KAAK,CAAN,CAAM,CAAN,EAAA,aAAA,CAAA;AAC7BI,IAAAA,QAAQ,EAAEJ,KAAK,CAACM,CAAC,GADY,CACd,CADc;AAE7BS,IAAAA,SAAS,EAAEC,OAAO,CAAPA,GAAAA,GAAcR,aAAa,GAAG;AAFZ,GAAA,EAD6B,OAC7B,CAAA,CAA9B,CAD2D,CAM3D;;AACA,MAAIK,OAAO,KAAX,SAAA,EAA2B;AAC1B,WAAOP,CAAC,GAAR,CAAA;AAR0D,GAAA,CAU3D;AACA;;;AACA,MAAIK,IAAI,CAAJA,GAAAA,CAAAA,aAAAA,IAAJ,OAAA,EAAuC;AACtC,WAAOL,CAAC,GAAR,CAAA;AAb0D,GAAA,CAe3D;;;AACA,MAAIA,CAAC,KAAKN,KAAK,CAALA,MAAAA,GAAV,CAAA,EAA4B;AAC3B,WAAA,CAAA;AAjB0D,GAAA,CAmB3D;;;AACA,SAAOO,YAAY,CAAA,KAAA,EAAA,aAAA,EAAA,OAAA,EAAgCD,CAAC,GAApD,CAAmB,CAAnB;AACA;AAED;;;;;;;;AAMA,SAAA,kBAAA,CAAA,KAAA,EAAA,KAAA,EAA0C;AACzC,SAAO,KAAK,CAAL,MAAA,CAAa,UAAA,KAAA,EAAwB;AAAA,QAArBW,IAAqB,GAAA,KAAA,CAArBA,IAAqB;AAAA,QAAfC,QAAe,GAAA,KAAA,CAAfA,QAAe,CAAA,CAC3C;;AACAD,IAAAA,IAAI,GAAGA,IAAI,IAFgC,QAE3CA,CAF2C,CAG3C;AACA;;AACA,QAAA,IAAA,EAAU;AACT,aAAOnB,KAAK,CAALA,OAAAA,CAAAA,IAAAA,KAAP,CAAA;AAN0C,KAAA,CAQ3C;AACA;AACA;;;AACA,WAAA,IAAA;AAXD,GAAO,CAAP;AAaA","sourcesContent":["import getStepDenominator from './getStepDenominator'\r\nimport getStepMinTime from './getStepMinTime'\r\nimport { getRoundFunction } from '../round'\r\n\r\n/**\r\n * Finds an appropriate `step` of `steps` for the time interval (in seconds).\r\n *\r\n * @param {Object[]} steps - Time formatting steps.\r\n *\r\n * @param {number} secondsPassed - Time interval (in seconds).\r\n *                                 `< 0` for past dates and `> 0` for future dates.\r\n *\r\n * @param {number} options.now - Current timestamp.\r\n *\r\n * @param {boolean} [options.future] - Whether the date should be formatted as a future one\r\n *                                     instead of a past one.\r\n *\r\n * @param {string} [options.round] - (undocumented) Rounding mechanism.\r\n *\r\n * @param {string[]} [options.units] - A list of allowed time units.\r\n *                                     (Example: ['second', 'minute', 'hour', …])\r\n *\r\n * @param {boolean} [options.getNextStep] - Pass true to return `[step, nextStep]` instead of just `step`.\r\n *\r\n * @return {Object|Object[]} [step] — Either a `step` or `[prevStep, step, nextStep]`.\r\n */\r\nexport default function getStep(steps, secondsPassed, { now, future, round, units, getNextStep }) {\r\n\t// Ignore steps having not-supported time units in `formatAs`.\r\n\tsteps = filterStepsByUnits(steps, units)\r\n\tconst step = _getStep(steps, secondsPassed, { now, future, round })\r\n\tif (getNextStep) {\r\n\t\tif (step) {\r\n\t\t\tconst prevStep = steps[steps.indexOf(step) - 1]\r\n\t\t\tconst nextStep = steps[steps.indexOf(step) + 1]\r\n\t\t\treturn [prevStep, step, nextStep]\r\n\t\t}\r\n\t\treturn [undefined, undefined, steps[0]]\r\n\t}\r\n\treturn step\r\n}\r\n\r\nfunction _getStep(steps, secondsPassed, { now, future, round }) {\r\n\t// If no steps fit the conditions then return nothing.\r\n\tif (steps.length === 0) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Find the most appropriate step.\r\n\tconst i = getStepIndex(steps, secondsPassed, {\r\n\t\tnow,\r\n\t\tfuture: future || secondsPassed < 0,\r\n\t\tround\r\n\t})\r\n\r\n\t// If no step is applicable the return nothing.\r\n\tif (i === -1) {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst step = steps[i]\r\n\r\n\t// Apply granularity to the time amount\r\n\t// (and fall back to the previous step\r\n\t//  if the first level of granularity\r\n\t//  isn't met by this amount)\r\n\tif (step.granularity) {\r\n\t\t// Recalculate the amount of seconds passed based on `granularity`.\r\n\t\tconst secondsPassedGranular = getRoundFunction(round)((Math.abs(secondsPassed) / getStepDenominator(step)) / step.granularity) * step.granularity\r\n\t\t// If the granularity for this step is too high,\r\n\t\t// then fall back to the previous step.\r\n\t\t// (if there is any previous step)\r\n\t\tif (secondsPassedGranular === 0 && i > 0) {\r\n\t\t\treturn steps[i - 1]\r\n\t\t}\r\n\t}\r\n\r\n\treturn step\r\n}\r\n\r\n/**\r\n * Iterates through steps until it finds the maximum one satisfying the `minTime` threshold.\r\n * @param  {Object} steps - Steps.\r\n * @param  {number} secondsPassed - How much seconds have passed since the date till `now`.\r\n * @param  {number} options.now - Current timestamp.\r\n * @param  {boolean} options.future - Whether the time interval should be formatted as a future one.\r\n * @param  {number} [i] - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\r\nfunction getStepIndex(steps, secondsPassed, options, i = 0) {\r\n\tconst minTime = getStepMinTime(steps[i], {\r\n\t\tprevStep: steps[i - 1],\r\n\t\ttimestamp: options.now - secondsPassed * 1000,\r\n\t\t...options\r\n\t})\r\n\t// If `minTime` isn't defined or deduceable for this step, then stop.\r\n\tif (minTime === undefined) {\r\n\t\treturn i - 1\r\n\t}\r\n\t// If the `minTime` threshold for moving from previous step\r\n\t// to this step is too high then return the previous step.\r\n\tif (Math.abs(secondsPassed) < minTime) {\r\n\t\treturn i - 1\r\n\t}\r\n\t// If it's the last step then return it.\r\n\tif (i === steps.length - 1) {\r\n\t\treturn i\r\n\t}\r\n\t// Move to the next step.\r\n\treturn getStepIndex(steps, secondsPassed, options, i + 1)\r\n}\r\n\r\n/**\r\n * Leaves only allowed steps.\r\n * @param  {Object[]} steps\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\r\nfunction filterStepsByUnits(steps, units) {\r\n\treturn steps.filter(({ unit, formatAs }) => {\r\n\t\t// \"unit\" is now called \"formatAs\".\r\n\t\tunit = unit || formatAs\r\n\t\t// If this step has a `unit` defined\r\n\t\t// then this `unit` must be in the list of allowed `units`.\r\n\t\tif (unit) {\r\n\t\t\treturn units.indexOf(unit) >= 0\r\n\t\t}\r\n\t\t// A step is not required to specify a `unit`:\r\n\t\t// alternatively, it could specify `format()`.\r\n\t\t// (see \"twitter\" style for an example)\r\n\t\treturn true\r\n\t})\r\n}"]},"metadata":{},"sourceType":"module"}